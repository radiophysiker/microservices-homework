# Правила для проекта микросервисов на Go

## Общая информация о проекте
Это учебный проект курса "Микросервисы, как в BigTech 2.0" от Олега Козырева.
Проект представляет собой систему микросервисов для управления заказами космических кораблей, состоящую из:
- **Order Service** - управление заказами (REST API + gRPC)
- **Inventory Service** - управление инвентарем деталей (gRPC)
- **Payment Service** - обработка платежей (gRPC)

## Архитектура проекта

### Структура монорепозитория
- Используется Go Workspaces (`go.work`) для управления несколькими модулями
- Каждый сервис - отдельный Go модуль в своей директории
- Общие компоненты вынесены в модуль `shared`

### Модули проекта
- `inventory/` - сервис инвентаря (MongoDB)
- `order/` - сервис заказов (PostgreSQL + REST API)
- `payment/` - сервис платежей
- `shared/` - общие компоненты (proto, OpenAPI, сгенерированный код)

### Принципы архитектуры
- **Clean Architecture** - разделение на слои: API, Service, Repository
- **Dependency Injection** - использование интерфейсов для абстракции
- **Domain-Driven Design** - доменные модели отделены от инфраструктуры

## Технологический стек

### Основные технологии
- **Go 1.25** - основной язык разработки
- **gRPC** - межсервисное взаимодействие
- **OpenAPI 3.0** - REST API спецификация
- **Protocol Buffers** - сериализация данных
- **PostgreSQL** - основная БД для Order Service
- **MongoDB** - БД для Inventory Service

### Инструменты разработки
- **Buf** - управление proto файлами
- **Ogen** - генерация Go кода из OpenAPI
- **Goose** - миграции БД
- **Docker Compose** - локальная инфраструктура
- **Task** - автоматизация задач

### Качество кода
- **golangci-lint** - линтинг
- **gofumpt** - форматирование кода
- **gci** - сортировка импортов
- **testify** - тестирование
- **mockery** - генерация моков

## Правила разработки

### Структура сервиса
Каждый сервис должен следовать структуре:
```
service/
├── cmd/main.go              # Точка входа
├── internal/
│   ├── api/                 # HTTP/gRPC handlers
│   ├── service/             # Бизнес-логика
│   ├── repository/          # Доступ к данным
│   ├── model/               # Доменные модели
│   └── converter/           # Конвертеры между слоями
├── migrations/              # SQL миграции (для PostgreSQL)
└── go.mod                   # Go модуль
```

### Именование
- **Пакеты**: snake_case (например, `order_service`)
- **Файлы**: snake_case (например, `create_order.go`)
- **Структуры**: PascalCase (например, `OrderService`)
- **Интерфейсы**: PascalCase с суффиксом интерфейса (например, `OrderRepository`)
- **Константы**: PascalCase (например, `OrderStatusPending`)

### Импорты
Используй `gci` для сортировки импортов в следующем порядке:
1. Стандартная библиотека Go
2. Внешние зависимости
3. Внутренние пакеты проекта (с префиксом `github.com/radiophysiker/microservices-homework`)

### Обработка ошибок
- Используй кастомные типы ошибок в `internal/model/errors.go`
- Возвращай доменные ошибки из сервисного слоя
- Конвертируй доменные ошибки в HTTP/gRPC ошибки в API слое

### Тестирование
- Покрывай тестами бизнес-логику (service слой)
- Используй моки для внешних зависимостей
- Тесты должны быть в файлах `*_test.go`
- Используй testify для assertions

### API контракты
- **gRPC**: Определяй в `shared/proto/*/v1/*.proto`
- **REST**: Определяй в `shared/api/*/v1/*.yaml`
- Генерируй код через `task gen`
- Версионируй API через директории `v1`, `v2`, etc.

### База данных
- **PostgreSQL**: Используй для Order Service с миграциями через Goose
- **MongoDB**: Используй для Inventory Service
- Миграции должны быть в директории `migrations/`
- Применяй миграции автоматически при старте сервиса

### Docker и развертывание
- Конфигурации Docker Compose в `deploy/compose/`
- Используй health checks для контейнеров БД
- Создавай именованные тома для персистентности данных
- Используй общую сеть `microservices-net`

## Команды разработки

### Основные команды Task
- `task format` - форматирование кода
- `task lint` - проверка линтером
- `task test` - запуск тестов
- `task test-coverage` - тесты с покрытием
- `task gen` - генерация кода из proto/OpenAPI
- `task up-all` - запуск всех сервисов
- `task test-api` - тестирование API

### Работа с БД
- `task up-core` - запуск базовой инфраструктуры
- `task up-order` - запуск PostgreSQL для Order Service
- `task up-inventory` - запуск MongoDB для Inventory Service

## Специфичные правила

### Для Order Service
- Используй PostgreSQL с миграциями
- Реализуй REST API через OpenAPI
- Поддерживай статусы заказов: PENDING_PAYMENT, PAID, CANCELLED, ASSEMBLED
- Интегрируйся с Inventory и Payment сервисами через gRPC

### Для Inventory Service
- Используй MongoDB для хранения деталей
- Предоставляй gRPC API для поиска деталей
- Поддерживай фильтрацию по категориям, производителям, тегам

### Для Payment Service
- Реализуй gRPC API для обработки платежей
- Поддерживай различные методы оплаты (CARD, SBP, CREDIT_CARD, etc.)
- Возвращай UUID транзакции

### Для Shared модуля
- Содержи proto файлы и OpenAPI спецификации
- Генерируй Go код из контрактов
- Не добавляй бизнес-логику

## Рекомендации по коду

### Контекст
- Всегда передавай `context.Context` в функции, которые могут быть отменены
- Используй таймауты для внешних вызовов
- Обрабатывай отмену контекста

### Логирование
- Используй структурированное логирование
- Логируй на уровне INFO для важных операций
- Логируй на уровне ERROR для ошибок
- Не логируй чувствительные данные (пароли, токены)

### Конфигурация
- Используй переменные окружения для конфигурации
- Предоставляй значения по умолчанию
- Валидируй конфигурацию при старте

### Безопасность
- Валидируй входные данные
- Используй prepared statements для SQL
- Не логируй чувствительную информацию
- Используй HTTPS в продакшене

## Отладка и мониторинг

### Логи
- Используй структурированные логи в JSON формате
- Включай correlation ID для трассировки запросов
- Логируй время выполнения операций

### Метрики
- Используй OpenTelemetry для метрик
- Отслеживай количество запросов, время ответа, ошибки
- Мониторь использование ресурсов БД

### Здоровье сервисов
- Реализуй health check endpoints
- Проверяй доступность внешних зависимостей
- Возвращай статус готовности сервиса

## При создании нового кода

1. **Следуй существующим паттернам** - изучи похожий код в проекте
2. **Используй интерфейсы** - абстрагируйся от конкретных реализаций
3. **Пиши тесты** - покрывай новую функциональность тестами
4. **Документируй** - добавляй комментарии к публичным API
5. **Форматируй код** - используй `task format` перед коммитом
6. **Проверяй линтером** - используй `task lint` для проверки качества

## При работе с API

1. **Обновляй контракты** - сначала измени proto/OpenAPI файлы
2. **Генерируй код** - используй `task gen` для обновления сгенерированного кода
3. **Реализуй handlers** - создавай обработчики в api слое
4. **Тестируй API** - используй `task test-api` для проверки работоспособности

## При работе с БД

1. **Создавай миграции** - добавляй SQL файлы в migrations/
2. **Тестируй миграции** - проверяй их применение и откат
3. **Используй транзакции** - для операций, требующих консистентности
4. **Индексируй** - добавляй индексы для часто используемых запросов

Помни: цель проекта - изучение микросервисной архитектуры и лучших практик разработки на Go. Следуй принципам чистой архитектуры и пиши качественный, тестируемый код.
